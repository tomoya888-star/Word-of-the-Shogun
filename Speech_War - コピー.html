<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sengoku Auto Battler - Campaign Mode</title>
    <style>
        :root {
            --primary: #3498db;
            --danger: #e74c3c;
            --boss: #c0392b;
            --bg-grass: #a8e6cf;
            --ui-bg: rgba(44, 62, 80, 0.95);
        }
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Hiragino Maru Gothic ProN', 'Rounded M+ 1c', sans-serif;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-radius: 12px;
            overflow: hidden;
            background-color: var(--bg-grass);
            width: 800px;
            height: 450px;
        }
        canvas {
            display: block;
        }
        .btn {
            background-color: #f1c40f;
            color: #333;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s, background-color 0.2s;
        }
        .btn:hover { background-color: #f39c12; transform: translateY(-2px); }
        .btn:active { transform: translateY(2px); }
        .btn:disabled { background-color: #95a5a6; cursor: not-allowed; transform: none; }

        #wave-info {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.5);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 18px;
            pointer-events: none;
        }

        /* Loading Screen */
        #loading-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #2c3e50;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 200; color: white;
        }
        .loader {
            border: 6px solid #f3f3f3; border-top: 6px solid var(--primary); border-radius: 50%;
            width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- Campaign Mode UI --- */
        .novel-ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--ui-bg);
            display: none; flex-direction: column;
            z-index: 100; color: white;
        }

        /* Select General Phase */
        .select-general-ui {
            display: flex; justify-content: space-around; align-items: center; height: 100%; padding: 0 20px;
        }
        .general-card {
            background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px;
            text-align: center; cursor: pointer; width: 35%; border: 2px solid transparent;
            transition: all 0.2s;
        }
        .general-card:hover { transform: scale(1.05); border-color: #f1c40f; background: rgba(255,255,255,0.2); }
        .general-card img { width: 120px; height: 120px; border-radius: 50%; border: 3px solid #ccc; object-fit: cover; background: #fff;}
        .general-card h3 { margin: 10px 0; color: #f1c40f; }
        .general-card p { font-size: 14px; line-height: 1.5; margin: 0; color: #ecf0f1; }

        /* Conversation Phase */
        .novel-content { flex: 1; display: flex; padding: 20px; box-sizing: border-box; overflow: hidden; }
        .character-area {
            flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
            border-right: 1px solid rgba(255,255,255,0.2); padding-right: 20px;
        }
        .character-img { width: 140px; height: 140px; border-radius: 50%; border: 4px solid var(--primary); object-fit: cover; background: #fff; }
        .character-info { margin-top: 15px; width: 100%; }
        .memory-box {
            font-size: 13px; text-align: left; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; margin-top: 10px;
            color: #bdc3c7; height: 60px; overflow-y: auto;
        }
        .log-area {
            flex: 2; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 15px; margin-left: 20px;
            overflow-y: auto; display: flex; flex-direction: column; gap: 10px;
        }
        .log-entry { padding: 12px; border-radius: 8px; font-size: 15px; line-height: 1.4; }
        .log-player { background: rgba(52, 152, 219, 0.4); align-self: flex-end; width: 85%; border-bottom-right-radius: 0; }
        .log-general { background: rgba(46, 204, 113, 0.4); align-self: flex-start; width: 85%; border-bottom-left-radius: 0; }

        .input-area {
            height: 120px; padding: 15px 20px; background: #34495e; display: flex; gap: 15px; border-top: 1px solid #2c3e50;
        }
        .input-area textarea {
            flex: 1; height: 100%; font-size: 16px; padding: 10px; border-radius: 8px; border: 2px solid #7f8c8d;
            box-sizing: border-box; resize: none; background: #ecf0f1; color: #2c3e50;
        }
        .input-area textarea:focus { outline: none; border-color: var(--primary); }
        .action-buttons { display: flex; flex-direction: column; gap: 10px; width: 150px; }
        .action-buttons .btn { flex: 1; width: 100%; padding: 0; }

        /* --- Real-time Battle Command UI --- */
        #battle-command-ui {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 60px;
            background: rgba(0, 0, 0, 0.7); display: none; align-items: center; padding: 0 15px;
            box-sizing: border-box; z-index: 150; border-top: 2px solid var(--primary);
        }
        #battle-general-icon {
            width: 45px; height: 45px; border-radius: 50%; border: 2px solid #f1c40f;
            background: #fff; object-fit: cover; margin-right: 10px;
        }
        #battle-input {
            flex: 1; height: 36px; border-radius: 18px; border: none; padding: 0 15px;
            font-size: 14px; margin-right: 10px;
        }
        #battle-send-btn {
            height: 36px; padding: 0 20px; font-size: 14px; border-radius: 18px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="450"></canvas>
    
    <div id="loading-screen">
        <div class="loader"></div>
        <h2 id="loading-text">Loading Image Assets...</h2>
    </div>

    <div id="wave-info">Wave 1 - 0:00</div>

    <!-- --- Real-time Battle Command Bar --- -->
    <div id="battle-command-ui">
        <img id="battle-general-icon" src="" alt="">
        <input type="text" id="battle-input" placeholder="Give orders in real-time...">
        <button id="battle-send-btn" class="btn" onclick="submitBattleCommand()">SEND</button>
    </div>

    <!-- --- Campaign UI Container --- -->
    <div id="phase-ui-container" class="novel-ui-container">
        
        <!-- 1. Select General Phase -->
        <div id="ui-select-general" class="select-general-ui">
            <h2 style="position: absolute; top: 20px; width: 100%; text-align: center; margin: 0;">Choose a General to fight alongside you</h2>
            
            <div class="general-card" onclick="selectGeneral('hotblooded')">
                <img id="sel-img-hot" src="" alt="Hot-blooded">
                <h3>Kotaro Sanada</h3>
                <p>Hot-blooded rookie. Energetic but reckless. Shows great potential when inspired.</p>
            </div>
            
            <div class="general-card" onclick="selectGeneral('veteran')">
                <img id="sel-img-vet" src="" alt="Veteran">
                <h3>Kanbei Kuroda</h3>
                <p>Calm veteran. Cautious, sometimes pessimistic. Excels at solid defense.</p>
            </div>
        </div>

        <!-- 2. Conversation Phase -->
        <div id="ui-conversation" style="display: none; height: 100%; flex-direction: column;">
            <div class="novel-content">
                <div class="character-area">
                    <img id="conv-char-img" class="character-img" src="" alt="">
                    <div class="character-info">
                        <h3 id="conv-char-name" style="margin: 0 0 5px 0; text-align: center; color: #f1c40f;"></h3>
                        <p id="conv-char-personality" style="font-size: 12px; margin: 0 0 10px 0; text-align: center;"></p>
                        <div class="memory-box">
                            <b style="color: #fff;">[General's Memory]</b><br>
                            <span id="conv-char-memory">None</span>
                        </div>
                    </div>
                </div>
                <div id="conv-log-area" class="log-area">
                    <!-- Conversation logs will be added here -->
                </div>
            </div>
            <div class="input-area">
                <textarea id="conv-input" placeholder="Enter your words, General..."></textarea>
                <div class="action-buttons">
                    <button id="conv-submit-btn" class="btn" onclick="submitConversation()">Speak</button>
                    <button id="conv-next-btn" class="btn" style="display: none; background-color: var(--danger); color: white;" onclick="goToNextPhase()">Next</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const waveInfo = document.getElementById('wave-info');

    // --- Game State (Campaign Mode) ---
    const GameState = {
        // Campaign / State Management
        currentPhase: 'LOADING', 
        nextPhaseTarget: '',
        generalMemory: '',
        selectedGeneral: null,
        
        // Battle Management
        units: [],
        damageTexts: [],
        isPaused: true,
        gameTime: 0,
        lastTimestamp: 0,
        wave: 1,
        gameStatus: 'selecting',
        currentTactic: 'NORMAL',
        currentBuffs: { atkMult: 1.0, spdMult: 1.0, defBuff: 0, buffType: null },

        // Real-time Tactical Intervention
        battleSpeech: { text: '', timer: 0 }
    };

    // General Data Definition
    const GENERALS = {
        hotblooded: {
            id: 'hotblooded',
            name: 'Kotaro Sanada',
            personality: '[Personality] Hot-blooded rookie. Energetic but reckless.',
            faceBrave: 'hotblooded_happy',
            faceScared: 'hotblooded_sad'
        },
        veteran: {
            id: 'veteran',
            name: 'Kanbei Kuroda',
            personality: '[Personality] Calm veteran. Cautious, sometimes pessimistic.',
            faceBrave: 'veteran_happy',
            faceScared: 'veteran_sad'
        }
    };

    // --- Image Asset Management ---
    const Assets = {
        bg: new Image(), ally: new Image(), enemy: new Image(), boss: new Image(),
        hotblooded_happy: new Image(), hotblooded_sad: new Image(),
        veteran_happy: new Image(), veteran_sad: new Image()
    };

    async function loadAssets() {
        const loadImg = (src, targetProp) => {
            return new Promise(resolve => {
                Assets[targetProp].onload = resolve;
                Assets[targetProp].onerror = resolve; 
                Assets[targetProp].src = src;
            });
        };

        await Promise.all([
            loadImg('assets/background.png', 'bg'),
            loadImg('assets/samurai.png', 'ally'),
            loadImg('assets/ninja.png', 'enemy'),
            loadImg('assets/boss.png', 'boss'),
            loadImg('assets/hotblooded_happy.png', 'hotblooded_happy'),
            loadImg('assets/hotblooded_sad.png', 'hotblooded_sad'),
            loadImg('assets/veteran_happy.png', 'veteran_happy'),
            loadImg('assets/veteran_sad.png', 'veteran_sad')
        ]);
        
        document.getElementById('loading-screen').style.display = 'none';
        
        // Set images for the selection screen
        document.getElementById('sel-img-hot').src = Assets.hotblooded_happy.src;
        document.getElementById('sel-img-vet').src = Assets.veteran_happy.src;
        
        // Go to selection phase after loading
        changePhase('SELECT_GENERAL');
    }

    // --- Campaign Phase Progression Logic ---
    function changePhase(newPhase) {
        GameState.currentPhase = newPhase;
        
        const uiContainer = document.getElementById('phase-ui-container');
        const uiSelect = document.getElementById('ui-select-general');
        const uiConv = document.getElementById('ui-conversation');
        const battleUI = document.getElementById('battle-command-ui');
        
        // Hide everything first
        uiContainer.style.display = 'flex';
        uiSelect.style.display = 'none';
        uiConv.style.display = 'none';
        battleUI.style.display = 'none';
        GameState.isPaused = true;
        
        if (newPhase === 'SELECT_GENERAL') {
            uiSelect.style.display = 'flex';
        } 
        else if (newPhase.includes('PRE_') || newPhase.includes('POST_')) {
            uiConv.style.display = 'flex';
            setupConversationPhase(newPhase);
        }
        else if (newPhase === 'BATTLE_1' || newPhase === 'BATTLE_2') {
            uiContainer.style.display = 'none'; 
            battleUI.style.display = 'flex';
            document.getElementById('battle-general-icon').src = Assets[GameState.selectedGeneral.faceBrave].src;
            startBattle(newPhase === 'BATTLE_1' ? 1 : 2);
        }
        else if (newPhase === 'RESULT') {
            uiContainer.style.display = 'none';
            GameState.isPaused = false;
            GameState.gameStatus = 'win';
        }
    }

    // Select General
    window.selectGeneral = function(generalId) {
        GameState.selectedGeneral = GENERALS[generalId];
        GameState.generalMemory = ""; // Reset memory
        changePhase('PRE_BATTLE_1');
    };

    // Initialize Conversation Phase
    function setupConversationPhase(phase) {
        const gen = GameState.selectedGeneral;
        
        // Update general information display
        document.getElementById('conv-char-img').src = Assets[gen.faceBrave].src; // Default to brave face
        document.getElementById('conv-char-name').innerText = gen.name;
        document.getElementById('conv-char-personality').innerText = gen.personality;
        document.getElementById('conv-char-memory').innerText = GameState.generalMemory || "None";
        
        // Clear and initialize logs
        document.getElementById('conv-log-area').innerHTML = '';
        document.getElementById('conv-input').value = '';
        document.getElementById('conv-input').disabled = false;
        
        // Reset button states
        document.getElementById('conv-submit-btn').style.display = 'block';
        document.getElementById('conv-submit-btn').disabled = false;
        document.getElementById('conv-next-btn').style.display = 'none';
        
        let initialMessage = "";
        
        if (phase === 'PRE_BATTLE_1') {
            initialMessage = "General, it's time for our first battle! The troops are ready. Please give them some words of encouragement before we march!";
            document.getElementById('conv-input').placeholder = "e.g. Brave warriors, fear nothing and march forward!";
        } else if (phase === 'POST_BATTLE_1') {
            initialMessage = "We did it! A glorious victory! ...But wait, I sense enemy reinforcements approaching!";
            document.getElementById('conv-input').placeholder = "e.g. Don't let your guard down, hold the line!";
        } else if (phase === 'PRE_BATTLE_2') {
            initialMessage = "The reinforcements are... a giant Oni-Musha! We'll be wiped out if we face it head-on. What are your orders!?";
            document.getElementById('conv-input').placeholder = "e.g. It's slow! Scatter and attack from both sides!";
        }
        
        addLog('general', initialMessage);
        setTimeout(() => document.getElementById('conv-input').focus(), 100);
    }

    function addLog(speaker, text) {
        const logArea = document.getElementById('conv-log-area');
        const div = document.createElement('div');
        div.className = 'log-entry ' + (speaker === 'player' ? 'log-player' : 'log-general');
        
        const name = speaker === 'player' ? 'General (You)' : GameState.selectedGeneral.name;
        div.innerHTML = `<b style="font-size:12px; opacity:0.8;">${name}</b><br>${text}`;
        
        logArea.appendChild(div);
        logArea.scrollTop = logArea.scrollHeight;
    }

    // Player speaks
    window.submitConversation = async function() {
        const rawText = document.getElementById('conv-input').value.trim();
        if (!rawText) return;
        
        document.getElementById('conv-input').value = '';
        document.getElementById('conv-input').disabled = true;
        
        const submitBtn = document.getElementById('conv-submit-btn');
        submitBtn.disabled = true;
        submitBtn.innerText = 'Consulting AI...';
        
        // --- Call External Gemini API ---
        const result = await callGeminiAPI(rawText);
        
        // UI Update with API Results
        addLog('player', result.translatedPlayerText);

        const nextBtn = document.getElementById('conv-next-btn');
        const isBad = result.situationScore < 40;
        
        if (GameState.currentPhase === 'PRE_BATTLE_1') {
            applyBuffsFromAI(result.situationScore, result.tactic);
            nextBtn.innerText = 'March to Battle';
            GameState.nextPhaseTarget = 'BATTLE_1';
        } 
        else if (GameState.currentPhase === 'POST_BATTLE_1') {
            nextBtn.innerText = 'Check Reinforcements';
            GameState.nextPhaseTarget = 'PRE_BATTLE_2';
        } 
        else if (GameState.currentPhase === 'PRE_BATTLE_2') {
            applyBuffsFromAI(result.situationScore, result.tactic);
            nextBtn.innerText = 'Final Battle';
            GameState.nextPhaseTarget = 'BATTLE_2';
        }
        
        const gen = GameState.selectedGeneral;
        document.getElementById('conv-char-img').src = isBad ? Assets[gen.faceScared].src : Assets[gen.faceBrave].src;

        GameState.generalMemory += (GameState.generalMemory ? " / " : "") + result.newMemory;
        document.getElementById('conv-char-memory').innerText = GameState.generalMemory;
        
        addLog('general', result.replyText);
        submitBtn.style.display = 'none';
        nextBtn.style.display = 'block';
    };

    // --- Real-time Tactical Intervention (Mid-Battle) ---
    window.submitBattleCommand = async function() {
        const input = document.getElementById('battle-input');
        const rawText = input.value.trim();
        if (!rawText || GameState.gameStatus !== 'playing') return;

        input.value = '';
        input.disabled = true;

        // --- Call External Gemini API ---
        const result = await callGeminiAPI(rawText);
        
        // Update memory and current tactics/buffs
        GameState.generalMemory += (GameState.generalMemory ? " / " : "") + result.newMemory;
        applyBuffsFromAI(result.situationScore, result.tactic);

        // Apply directly to alive units in real-time
        const buffs = GameState.currentBuffs;
        GameState.units.filter(u => u.isAlly && u.hp > 0).forEach(u => {
            u.attackDamage = u.baseAtk * buffs.atkMult;
            u.speed = u.baseSpd * buffs.spdMult;
            u.damageReduction = buffs.defBuff;
            u.buffType = buffs.buffType;
        });

        // Show feedback bubble on Canvas
        GameState.battleSpeech.text = result.replyText;
        GameState.battleSpeech.timer = 3000; 

        input.disabled = false;
        input.focus();
    };

// ‚úÖ ‰øÆÊ≠£Áâà applyBuffsFromAIÔºöSPLIT„ÇíÁã¨Á´ã„Åó„ÅüÂàÜÂ≤ê„Å®„Åó„Å¶Âá¶ÁêÜ
function applyBuffsFromAI(score, tactic) {
    const isBad = score < 40;
    GameState.currentTactic = tactic;

    if (isBad) {
        GameState.currentBuffs = { atkMult: 0.6, spdMult: 0.6, defBuff: -20, buffType: 'down' };
    } else if (tactic === 'DEFEND') {
        GameState.currentBuffs = { atkMult: 1.2, spdMult: 1.0, defBuff: 60, buffType: 'defup' };
    } else if (tactic === 'SPLIT') {
        // ‚úÖ SPLIT„ÅØÈÄüÂ∫¶ÈáçË¶ñ„ÉªÊîªÊíÉÊéß„Åà„ÇÅ„ÅÆÊåüÊíÉ„Éê„Éï
        GameState.currentBuffs = { atkMult: 1.5, spdMult: 2.0, defBuff: 0, buffType: 'up' };
    } else {
        // CHARGE
        GameState.currentBuffs = { atkMult: 2.5, spdMult: 2.5, defBuff: 20, buffType: 'up' };
    }
}

// ‚úÖ ‰øÆÊ≠£Áâà submitBattleCommandÔºöbuffsÂèÇÁÖß„ÇíapplyBuffsFromAIÂëº„Å≥Âá∫„ÅóÂæå„Å´ÁßªÂãï
window.submitBattleCommand = async function() {
    const input = document.getElementById('battle-input');
    const rawText = input.value.trim();
    if (!rawText || GameState.gameStatus !== 'playing') return;
    input.value = '';
    input.disabled = true;

    const result = await callGeminiAPI(rawText);

    // „Åæ„Åö„Çø„ÇØ„ÉÜ„Ç£„ÇØ„Çπ„Å®„Éê„Éï„ÇíÊõ¥Êñ∞
    GameState.generalMemory = GameState.generalMemory
        ? `${GameState.generalMemory} / ${result.newMemory}`
        : result.newMemory;
    applyBuffsFromAI(result.situationScore, result.tactic);

    // ‚úÖ applyBuffsFromAIÂëº„Å≥Âá∫„Åó„ÄåÂæå„Äç„Å´GameState.currentBuffs„ÇíÂèÇÁÖß
    const buffs = GameState.currentBuffs;
    GameState.units.filter(u => u.isAlly && u.hp > 0).forEach(u => {
        u.attackDamage = u.baseAtk * buffs.atkMult;
        u.speed       = u.baseSpd  * buffs.spdMult;
        u.damageReduction = buffs.defBuff;
        u.buffType    = buffs.buffType;
    });

    GameState.battleSpeech.text  = `[${result.tactic}] ${result.replyText}`;
    GameState.battleSpeech.timer = 3000;
    input.disabled = false;
    input.focus();
};


    // Enter key support for battle input
    document.getElementById('battle-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') submitBattleCommand();
    });

    window.goToNextPhase = function() {
        changePhase(GameState.nextPhaseTarget);
    };

    // --- Canvas Battle Processing ---
    
    class Unit {
        constructor(config) {
            this.x = config.x; this.y = config.y;
            this.isAlly = config.isAlly; this.isBoss = config.isBoss || false;
            
            this.radius = config.radius || (this.isBoss ? 40 : 15);
            this.color = this.isAlly ? '#3498db' : (this.isBoss ? '#c0392b' : '#e74c3c');
            
            if (this.isAlly) this.image = Assets.ally;
            else if (this.isBoss) this.image = Assets.boss;
            else this.image = Assets.enemy;
            
            this.maxHp = config.hp || 100;
            this.hp = this.maxHp;
            
            // Store base stats for mid-battle recalculation
            this.baseAtk = config.damage || 10;
            this.baseSpd = config.speed || 1.5;

            this.attackDamage = this.baseAtk;
            this.speed = this.baseSpd;
            this.attackRange = this.radius + 15;
            this.attackCooldown = config.cooldown || 1000;
            this.damageReduction = 0;
            
            this.lastAttackTime = 0;
            this.target = null;
            this.hitEffectTimer = 0;
            this.buffType = null;
        }

        update(deltaTime) {
    if (this.hp <= 0) return;
    if (this.hitEffectTimer > 0) this.hitEffectTimer -= deltaTime;

    const enemies = GameState.units.filter(u => u.isAlly !== this.isAlly && u.hp > 0);
    const allies = GameState.units.filter(u => u.isAlly === this.isAlly && u.hp > 0);
    const myIndex = allies.indexOf(this);

    let minDist = Infinity;
    this.target = null;
    for (let enemy of enemies) {
        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
        if (dist < minDist) {
            minDist = dist;
            this.target = enemy;
        }
    }

    let targetX = this.x;
    let targetY = this.y;
    let currentSpeed = this.speed;
    let isDefending = false;

    if (this.isAlly) {
        if (GameState.currentTactic === 'CHARGE') {
            currentSpeed = this.speed * 1.5;
        } else if (GameState.currentTactic === 'DEFEND') {
            const spacing = 45;
            const startY = (canvas.height - (allies.length - 1) * spacing) / 2;
            targetX = 350;
            targetY = startY + myIndex * spacing;
            isDefending = true;
        } else if (GameState.currentTactic === 'SPLIT') {
            // ‰∏ä‰∏ã2„É¨„Éº„É≥„Å´ÊåØ„ÇäÂàÜ„Åë„ÄÅX=420„ÅßÂæÖÊ©ü
            targetY = myIndex % 2 === 0 ? 80 : canvas.height - 140;
            targetX = 420;
        }
    }

    if (!this.target) {
        // Êïµ„Åå„ÅÑ„Å™„ÅÑÊôÇ„ÅÆÁßªÂãï
        if (this.isAlly) {
            if (isDefending) {
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 5) {
                    this.x += dx / dist * currentSpeed * deltaTime / 16;
                    this.y += dy / dist * currentSpeed * deltaTime / 16;
                }
            } else if (GameState.currentTactic === 'SPLIT') {
                // ‰∏ä‰∏ã„É¨„Éº„É≥„ÅÆY‰ΩçÁΩÆ„Å®ÂæÖÊ©üXÂú∞ÁÇπ„Å∏ÁßªÂãï
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 5) {
                    this.x += dx / dist * currentSpeed * deltaTime / 16;
                    this.y += dy / dist * currentSpeed * deltaTime / 16;
                }
                // ÂæÖÊ©ü„É©„Ç§„É≥„ÇíË∂Ö„Åà„Å¶ÂâçÈÄ≤„Åó„Å™„ÅÑ
                if (this.x > targetX) this.x = targetX;
            } else {
                // CHARGE: Âè≥Á´Ø„Å∏ÂâçÈÄ≤
                this.x += currentSpeed * deltaTime / 16;
            }
        } else {
            this.x -= this.speed * deltaTime / 16;
        }
    } else {
        let shouldChase = true;
        if (isDefending && minDist > this.attackRange + 80) shouldChase = false;

        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 5) {
            this.x += dx / dist * currentSpeed * deltaTime / 16;
            this.y += dy / dist * currentSpeed * deltaTime / 16;
        }

        if (shouldChase) {
            if (minDist > this.attackRange) {
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                if (this.isAlly && GameState.currentTactic === 'SPLIT') {
                    const biasY = targetY - this.y;
                    this.x += dx / minDist * currentSpeed * deltaTime / 16;
                    this.y += dy / minDist * Math.sign(biasY) * 0.8 * currentSpeed * 0.7 * deltaTime / 16;
                    // ÂæÖÊ©ü„É©„Ç§„É≥„Åã„ÇâÂ§ßÂπÖ„Å´Ââç„Å´Âá∫„Å™„ÅÑ
                    if (this.x > targetX + 80) this.x = targetX + 80;
                } else {
                    this.x += dx / minDist * currentSpeed * deltaTime / 16;
                    this.y += dy / minDist * currentSpeed * deltaTime / 16;
                }
            } else {
                // ÊîªÊíÉÁØÑÂõ≤ÂÜÖÔºöÊîªÊíÉÂá¶ÁêÜ
                if (GameState.gameTime - this.lastAttackTime > this.attackCooldown) {
                    const reduction = this.target.damageReduction || 0;
                    const finalDamage = Math.max(1, this.attackDamage * (1 - reduction / 100));
                    this.target.hp -= finalDamage;
                    this.target.hitEffectTimer = 150;
                    this.lastAttackTime = GameState.gameTime;
                    GameState.damageTexts.push({
                        x: this.target.x + Math.random() * 20 - 10,
                        y: this.target.y - this.target.radius - 10,
                        text: `-${Math.floor(finalDamage)}`,
                        life: 1000,
                        maxLife: 1000
                    });
                    this.x += this.isAlly ? 5 : -5;
                    setTimeout(() => { this.x -= this.isAlly ? 5 : -5; }, 50);
                }
            }
        }
    }

    this.y = Math.max(this.radius, Math.min(canvas.height - this.radius - 60, this.y));
}


        draw(ctx) {
            ctx.save();
            if (this.hitEffectTimer > 0) ctx.filter = 'brightness(200%)';

            let bounceY = 0; let rotation = 0;
            if (this.hp > 0 && GameState.gameStatus === 'playing') {
                bounceY = Math.abs(Math.sin(GameState.gameTime / 800 + this.x)) * 8; 
                rotation = Math.sin(GameState.gameTime / 1000 + this.x) * 0.1;
            }

            ctx.translate(this.x, this.y - bounceY);
            ctx.rotate(rotation);

            if (this.image && this.image.complete && this.image.naturalWidth !== 0) {
                const drawScale = 1.8;
                const scaledRadius = this.radius * drawScale;
                ctx.drawImage(this.image, -scaledRadius, -scaledRadius, scaledRadius * 2, scaledRadius * 2);
            } else {
                ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; ctx.fill();
                ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.stroke();
            }
            ctx.restore();

            if (this.buffType) {
                ctx.textAlign = 'center'; ctx.font = 'bold 16px sans-serif';
                const iconY = this.y - this.radius * 2.2 - bounceY;
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                const txt = this.buffType === 'down' ? 'üíÄ DOWN' : (this.buffType === 'def_up' ? 'üõ°Ô∏è UP' : '‚öîÔ∏è UP');
                ctx.fillText(txt, this.x + 1, iconY + 1);
                
                ctx.fillStyle = this.buffType === 'down' ? '#9b59b6' : (this.buffType === 'def_up' ? '#3498db' : '#e74c3c');
                ctx.fillText(txt, this.x, iconY);
            }

            const hpWidth = 40; const hpHeight = 6;
            const hpX = this.x - hpWidth / 2; const hpY = this.y - this.radius - 12;
            ctx.fillStyle = '#333'; ctx.fillRect(hpX, hpY, hpWidth, hpHeight);
            
            const hpPercent = Math.max(0, this.hp / this.maxHp);
            ctx.fillStyle = hpPercent > 0.5 ? '#2ecc71' : (hpPercent > 0.2 ? '#f1c40f' : '#e74c3c');
            ctx.fillRect(hpX, hpY, hpWidth * hpPercent, hpHeight);
            ctx.strokeStyle = '#000'; ctx.strokeRect(hpX, hpY, hpWidth, hpHeight);
        }
    }

    function startBattle(wave) {
        GameState.units = [];
        GameState.damageTexts = [];
        GameState.gameTime = 0;
        GameState.wave = wave;
        GameState.gameStatus = 'starting';
        GameState.stateStartTime = performance.now();
        GameState.isPaused = false;
        GameState.battleSpeech.timer = 0; 
        
        const buffs = GameState.currentBuffs;

        if (wave === 1) {
            waveInfo.innerText = "Wave 1 - Battle Start";
            for (let i = 0; i < 5; i++) {
                GameState.units.push(new Unit({ x: 80, y: 100 + i * 65, isAlly: true, hp: 100, damage: 20, speed: 1.0 }));
            }
            for (let i = 0; i < 2; i++) {
                GameState.units.push(new Unit({ x: 700, y: 180 + i * 100, isAlly: false, hp: 250, damage: 15, speed: 2.5 }));
            }
        } else if (wave === 2) {
            waveInfo.innerText = "Wave 2 - Giant Boss Appeared";
            for (let i = 0; i < 5; i++) {
                GameState.units.push(new Unit({ x: -50 - (i * 30), y: 100 + i * 65, isAlly: true, hp: 100, damage: 20, speed: 1.2 }));
            }
            for (let i = 0; i < 2; i++) {
                GameState.units.push(new Unit({ x: 850 + (i * 80), y: 150 + i * 150, isAlly: false, isBoss: true, radius: 40, hp: 1500, damage: 40, speed: 1.25 }));
            }
        }
        
        // Apply Initial Buffs
        GameState.units.filter(u => u.isAlly).forEach(u => {
            u.attackDamage = u.baseAtk * buffs.atkMult;
            u.speed = u.baseSpd * buffs.spdMult;
            u.damageReduction = buffs.defBuff;
            u.buffType = buffs.buffType;
        });
    }

    function drawBackground() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (Assets.bg && Assets.bg.complete && Assets.bg.naturalWidth !== 0) {
            ctx.drawImage(Assets.bg, 0, 0, canvas.width, canvas.height);
        }
    }

    // Helper to draw a speech bubble on Canvas
    function drawSpeechBubble(text, x, y) {
        ctx.font = 'bold 16px sans-serif';
        const metrics = ctx.measureText(text);
        const w = metrics.width + 20;
        const h = 30;
        
        ctx.fillStyle = 'white';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        
        // Bubble body
        ctx.beginPath();
        ctx.roundRect(x, y - h, w, h, 10);
        ctx.fill();
        ctx.stroke();

        // Triangle tail
        ctx.beginPath();
        ctx.moveTo(x + 10, y);
        ctx.lineTo(x + 20, y);
        ctx.lineTo(x + 15, y + 10);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = '#333';
        ctx.textAlign = 'left';
        ctx.fillText(text, x + 10, y - 10);
    }

// --- Gemini API ---
// ‚ö†Ô∏è Êú¨Áï™Ââç„Å´API„Ç≠„Éº„ÇíÁí∞Â¢ÉÂ§âÊï∞„ÇÑÂà•„Éï„Ç°„Ç§„É´„Å´ÁßªÂãï„Åô„Çã„Åì„Å®
const API_KEY = 'AIzaSyB22uF3dEsRRRk6FSe6Np3bBBorsWk6T3M';

async function callGeminiAPI(userInput) {
    console.log('Gemini API Calling with input:', userInput);

    const MODEL = 'gemini-2.5-flash';
    const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${API_KEY}`;

    const memorySnippet = (GameState.generalMemory || 'None').slice(0, 150);
    const personality = GameState.selectedGeneral ? GameState.selectedGeneral.personality : 'Unknown';

    const systemPrompt = `You are an NPC General in a Sengoku strategy game.
Personality: ${personality}
Memory: ${memorySnippet}

The Commander (player) has spoken in Japanese. Your tasks:
1. Translate the Japanese input to English.
2. Infer the Commander's INTENDED tactic from the meaning and context: CHARGE, DEFEND, or SPLIT.
   - CHARGE: aggressive, attack, push forward, any offensive intent
   - DEFEND: hold, wait, protect, retreat, cautious intent
   - SPLIT: flank, surround, divide forces, pincer, any splitting intent
   - If unclear, default to CHARGE
3. The tactic you output MUST reflect the Commander's intent, NOT your personality preference.
4. React to the order based on your personality:
   - If the order suits your personality ‚Üí respond with enthusiasm
   - If the order clashes with your personality ‚Üí express frustration or doubt, BUT explicitly state you will obey
5. situationScore reflects YOUR confidence in this order (0-100, low if you disagree with the order)
6. newMemory: short English summary of this exchange (max 20 words)

Output ONLY a raw JSON object:
{"translatedPlayerText":"...","situationScore":75,"personalityScore":80,"passionScore":80,"tactic":"CHARGE","replyText":"...","newMemory":"..."}

CRITICAL: tactic must always match the Commander's intent. You may hate the order but you must execute it.`;

    const payload = {
        systemInstruction: {
            parts: [{ text: systemPrompt }]
        },
        contents: [
            {
                role: 'user',
                parts: [{ text: userInput }]
            }
        ],
        generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 1024,
            responseMimeType: 'application/json'
        }
    };

    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        const data = await response.json();

        if (!response.ok) {
            console.error('FULL API ERROR:', data);
            throw new Error(data.error ? data.error.message : 'Unknown API Error');
        }

        let jsonText = data.candidates[0].content.parts[0].text.trim();
        jsonText = jsonText.replace(/^```json\s*/i, '').replace(/```\s*$/i, '').trim();

        const firstBrace = jsonText.indexOf('{');
        const lastBrace = jsonText.lastIndexOf('}');
        if (firstBrace !== -1 && lastBrace !== -1) {
            jsonText = jsonText.substring(firstBrace, lastBrace + 1);
        }

        let result;
        try {
            result = JSON.parse(jsonText);
        } catch (parseErr) {
            console.warn('JSON parse failed, using fallback. Raw:', jsonText);
            return buildFallbackResponse(userInput);
        }

        if (!result.tactic || !['CHARGE', 'DEFEND', 'SPLIT'].includes(result.tactic)) {
            result.tactic = 'CHARGE';
        }
        if (typeof result.situationScore !== 'number') result.situationScore = 75;

        GameState.generalMemory = result.newMemory;
        return result;

    } catch (error) {
        console.error('Gemini API Error details:', error);
        return buildFallbackResponse(userInput);
    }
}



// „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: APIÂ§±ÊïóÊôÇ„ÇÇ„Ç≤„Éº„É†„ÅåÊ≠¢„Åæ„Çâ„Å™„ÅÑ„ÉÄ„Éü„ÉºÂøúÁ≠î
function buildFallbackResponse(userInput) {
    let fallbackTactic = 'CHARGE';
    let fallbackScore = 80;
    let fallbackReply = 'Understood! Let us push forward with all our might!';

    const input = userInput || '';

    if (/ÂÆà|Èò≤|ÂæÖ|ÊÖé|ÈÄÄ|‰∏ã„Åå„Çå|„Åó„Å£„Åã„Çä|Âõ∫„ÇÅ/.test(input)) {
        fallbackTactic = 'DEFEND';
        fallbackScore = 60;
        fallbackReply = 'Hold the line! Form a defensive wall and let none pass!';
    } else if (/ÂàÜ|Êï£|Êåü|‰∏°Áøº|Âõ≤„ÇÅ|Âõû„ÇäËæº„ÇÅ|ÂÅ¥Èù¢/.test(input)) {
        fallbackTactic = 'SPLIT';
        fallbackScore = 75;
        fallbackReply = 'Split the forces! Pincer attack from both flanks!';
    } else if (/Êí§ÈÄÄ|ÈÄÉ|Ë≤†|Ë´¶|„ÉÄ„É°|ÁÑ°ÁêÜ/.test(input)) {
        fallbackTactic = 'DEFEND';
        fallbackScore = 25;
        fallbackReply = 'Are we retreating?! I will cover the rear with my life!';
    } else if (/Á™ÅÊíÉ|Á™Å„Å£Ëæº„ÇÅ|Ë°å„Åë|ÂâçÈÄ≤|Êîª„ÇÅ|Êñ¨„Çå|ÂÄí„Åõ/.test(input)) {
        fallbackTactic = 'CHARGE';
        fallbackScore = 95;
        fallbackReply = 'CHARGE! For glory and honor ‚Äî forward without hesitation!';
    }

    const fallbackMemory = `Commander ordered ${fallbackTactic} tactic (offline mode).`;
    GameState.generalMemory = GameState.generalMemory
        ? `${GameState.generalMemory} / ${fallbackMemory}`
        : fallbackMemory;

    return {
        translatedPlayerText: `[Offline] ${input}`,
        situationScore: fallbackScore,
        personalityScore: 80,
        passionScore: 80,
        tactic: fallbackTactic,
        replyText: fallbackReply + ' (Comms jammed!)',
        newMemory: fallbackMemory
    };
}


    function gameLoop(timestamp) {
        if (!GameState.lastTimestamp) GameState.lastTimestamp = timestamp;
        const deltaTime = timestamp - GameState.lastTimestamp;
        
        if (!GameState.isPaused && GameState.gameStatus === 'playing') {
            GameState.gameTime += deltaTime;

            GameState.units = GameState.units.filter(u => u.hp > 0);
            const allies = GameState.units.filter(u => u.isAlly);
            const enemies = GameState.units.filter(u => !u.isAlly);

            if (allies.length === 0) {
                GameState.gameStatus = 'lose';
            } else if (enemies.length === 0) {
                if (GameState.wave === 1) {
                    GameState.gameStatus = 'transition';
                    setTimeout(() => changePhase('POST_BATTLE_1'), 1500); 
                } else if (GameState.wave === 2) {
                    GameState.gameStatus = 'win';
                    setTimeout(() => changePhase('RESULT'), 1500);
                }
            }

            GameState.units.forEach(unit => unit.update(deltaTime));

            // Battle speech timer
            if (GameState.battleSpeech.timer > 0) {
                GameState.battleSpeech.timer -= deltaTime;
            }
        }

        drawBackground();
        GameState.units.sort((a, b) => a.y - b.y).forEach(unit => unit.draw(ctx));

        // Draw Battle Speech Bubble
        if (GameState.battleSpeech.timer > 0 && GameState.gameStatus === 'playing') {
            const iconX = 20;
            const iconY = 320; // „É™„Ç¢„É´„Çø„Ç§„É†UI„Å®Èáç„Å™„Çâ„Å™„ÅÑ„Çà„ÅÜË™øÊï¥
            const iconSize = 50;
            
            ctx.save();
            ctx.beginPath();
            ctx.arc(iconX + iconSize/2, iconY + iconSize/2, iconSize/2, 0, Math.PI * 2);
            ctx.clip();
            ctx.drawImage(Assets[GameState.selectedGeneral.faceBrave], iconX, iconY, iconSize, iconSize);
            ctx.restore();
            
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 3;
            ctx.stroke();

            drawSpeechBubble(GameState.battleSpeech.text, iconX + iconSize + 10, iconY + 20);
        }

        for (let i = GameState.damageTexts.length - 1; i >= 0; i--) {
            let dt = GameState.damageTexts[i];
            if (!GameState.isPaused) {
                dt.life -= deltaTime;
                dt.y -= 30 * (deltaTime / 1000); 
            }
            if (dt.life <= 0) { GameState.damageTexts.splice(i, 1); continue; }
            
            const alpha = Math.max(0, dt.life / dt.maxLife);
            ctx.fillStyle = `rgba(231, 76, 60, ${alpha})`;
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = 3; ctx.font = 'bold 24px sans-serif'; ctx.textAlign = 'center';
            ctx.strokeText(dt.text, dt.x, dt.y); ctx.fillText(dt.text, dt.x, dt.y);
        }

        if (GameState.gameStatus === 'starting') {
            const elapsed = timestamp - GameState.stateStartTime;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#f1c40f'; ctx.strokeStyle = '#c0392b'; ctx.lineWidth = 4;
            ctx.font = 'bold 80px sans-serif'; ctx.textAlign = 'center';
            
            const scale = Math.min(1.2, 0.5 + (elapsed / 1000));
            ctx.save(); ctx.translate(canvas.width / 2, canvas.height / 2); ctx.scale(scale, scale);
            ctx.strokeText('BATTLE START!', 0, 0); ctx.fillText('BATTLE START!', 0, 0); ctx.restore();

            if (elapsed > 2000) GameState.gameStatus = 'playing';
        } else if (GameState.gameStatus === 'win') {
            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#f1c40f'; ctx.strokeStyle = '#d35400'; ctx.lineWidth = 5;
            ctx.font = 'bold 80px sans-serif'; ctx.textAlign = 'center';
            ctx.strokeText('VICTORY', canvas.width / 2, canvas.height / 2); ctx.fillText('VICTORY', canvas.width / 2, canvas.height / 2);
        } else if (GameState.gameStatus === 'lose') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#e74c3c'; ctx.strokeStyle = '#c0392b'; ctx.lineWidth = 5;
            ctx.font = 'bold 80px sans-serif'; ctx.textAlign = 'center';
            ctx.strokeText('DEFEAT', canvas.width / 2, canvas.height / 2); ctx.fillText('DEFEAT', canvas.width / 2, canvas.height / 2);
        }

        GameState.lastTimestamp = timestamp;
        requestAnimationFrame(gameLoop);
    }

    // Entry point
    loadAssets().then(() => {
        requestAnimationFrame(gameLoop);
    });

</script>
</body>
</html>